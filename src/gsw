#!/bin/bash
source "$HOME/.local/bin/git-suite-lib.sh"

# --- GIT CHECK ---
check_git

# --- MAIN LOOP ---
SEL=0
VS=0
MAX=10

while true; do
    # 1. BRANCHES LADEN (Optimiert: Sortiert nach Committer Date)
    # Format: RefName | IsHead | UpstreamStatus | Subject
    RAW=$(git for-each-ref --sort=-committerdate refs/heads/ --format='%(refname:short)|%(HEAD)|%(upstream:track)|%(subject)')
    
    BRANCHES=()
    CURRENT_BRANCH=""
    
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        
        # Parse Line
        parse_line "$line" # P1=Name, P2=Head(*), P3=Track|Subject...
        
        # P3 enthält Track+Subject, wir müssen das splitten
        # Das Format oben ist etwas tricky mit parse_line, daher manuell:
        NAME="${line%%|*}"
        REST="${line#*|}"
        IS_HEAD="${REST%%|*}"
        REST="${REST#*|}"
        TRACK="${REST%%|*}"
        SUBJ="${REST#*|}"
        
        # Current Branch finden
        if [ "$IS_HEAD" == "*" ]; then
            CURRENT_BRANCH="$NAME"
            # Den aktuellen Branch wollen wir oft oben haben, aber durch Sortierung 
            # ist er eh meist oben (da gerade ausgecheckt = commit/checkout touch).
            # Wir markieren ihn visuell.
        fi
        
        # Zeile für UI speichern
        BRANCHES+=("$NAME|$IS_HEAD|$TRACK|$SUBJ")
    done <<< "$RAW"
    
    TOT=${#BRANCHES[@]}
    
    # Bounds Check
    [ $SEL -ge $TOT ] && SEL=$((TOT-1))
    [ $SEL -lt 0 ] && SEL=0
    
    # Scroll Check
    [ $SEL -lt $VS ] && VS=$SEL
    [ $SEL -ge $((VS+MAX)) ] && VS=$((SEL-MAX+1))
    
    # --- UI RENDER ---
    ui_header "BRANCH MANAGER" "Aktuell: $CURRENT_BRANCH"
    
    if [ $TOT -eq 0 ]; then
        echo "  ${C_MUTED}(Keine Branches gefunden)${RESET}"
    else
        for (( i=0; i<MAX; i++ )); do
            IDX=$((VS+i))
            [ $IDX -ge $TOT ] && break
            
            LINE="${BRANCHES[$IDX]}"
            # Split
            B_NAME="${LINE%%|*}"
            REST="${LINE#*|}"
            B_HEAD="${REST%%|*}"
            REST="${REST#*|}"
            B_TRACK="${REST%%|*}"
            B_SUBJ="${REST#*|}"
            
            IS_SEL="false"; [ $IDX -eq $SEL ] && IS_SEL="true"
            IS_CUR="false"; [ "$B_HEAD" == "*" ] && IS_CUR="true"
            
            # Label Styling
            LABEL="$B_NAME"
            if [[ "$B_NAME" =~ ^(main|master|dev|development)$ ]]; then
                LABEL="${BOLD}$B_NAME${RESET}"
            fi
            
            # Info String (Track + Subject)
            INFO=""
            [ -n "$B_TRACK" ] && INFO="${C_ACCENT}$B_TRACK${RESET} "
            INFO+="${B_SUBJ}"
            
            ui_item "$LABEL" "$INFO" "$IS_SEL" "$IS_CUR"
        done
    fi
    
    ui_line
    printf "${C_MUTED} [Enter] Switch  [n] New  [d] Delete  [r] Rename  [q] Quit${RESET}"
    
    read -rsn1 key
    if [[ $key == $'\x1b' ]]; then
        read -rsn2 k2
        case "$k2" in '[A') ((SEL--));; '[B') ((SEL++));; esac
        
    elif [[ $key == "" && $TOT -gt 0 ]]; then
        # SWITCH
        TARGET_LINE="${BRANCHES[$SEL]}"
        TARGET="${TARGET_LINE%%|*}"
        
        if [ "$TARGET" == "$CURRENT_BRANCH" ]; then
            # Wenn schon drauf, nichts tun (oder pullen?)
            continue
        fi
        
        cursor_on
        printf "\n${C_SUCCESS}Switching to '$TARGET'...${RESET}\n"
        if git switch "$TARGET"; then
             # VS Code Refresh Trick
            [ -d ".git" ] && touch .git/index
            exit 0
        else
            printf "${C_RED}Switch failed.${RESET}\n"
            read -rsn1 -p "Press key..."
        fi
        cursor_off
        
    elif [[ $key == "n" ]]; then
        # NEW
        ui_input "New Branch Name" ""
        NEW_NAME="$VAL"
        if [ -n "$NEW_NAME" ]; then
            if git switch -c "$NEW_NAME"; then
                [ -d ".git" ] && touch .git/index
                exit 0
            else
                read -rsn1 -p "Press key..."
            fi
        fi
        
    elif [[ $key == "d" && $TOT -gt 0 ]]; then
        # DELETE
        TARGET_LINE="${BRANCHES[$SEL]}"
        TARGET="${TARGET_LINE%%|*}"
        
        if [[ "$TARGET" == "$CURRENT_BRANCH" ]]; then
            tput cnorm; printf "\n${C_WARN}Cannot delete current branch.${RESET}"; sleep 1; tput civis; continue
        fi
        
        if [[ "$TARGET" =~ ^(main|master|dev)$ ]]; then
             tput cnorm; printf "\n${C_WARN}Protected branch: $TARGET${RESET}"; sleep 1; tput civis; continue
        fi
        
        cursor_on
        printf "\n${C_DANGER}DELETE '$TARGET'? [y/N]${RESET} "
        read -r y
        if [[ "$y" =~ ^[Yy]$ ]]; then
            git branch -D "$TARGET"
        fi
        cursor_off
        
    elif [[ $key == "r" && $TOT -gt 0 ]]; then
        # RENAME
        TARGET_LINE="${BRANCHES[$SEL]}"
        TARGET="${TARGET_LINE%%|*}"
        
        ui_input "Rename '$TARGET' to" "$TARGET"
        NEW_NAME="$VAL"
        
        if [ -n "$NEW_NAME" ] && [ "$NEW_NAME" != "$TARGET" ]; then
            git branch -m "$TARGET" "$NEW_NAME"
        fi
        
    elif [[ $key == "q" ]]; then
        exit 0
    fi
done