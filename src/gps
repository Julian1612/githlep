#!/bin/bash
source "$HOME/.local/bin/git-suite-lib.sh"

CFG="$HOME/.config/git-suite/repos.json"

# --- PYTHON ENGINE (Robust JSON Handling) ---
# Wir nutzen Inline-Python fÃ¼r sauberes JSON-Parsing ohne 'jq' AbhÃ¤ngigkeit
ensure_db() {
    if [ ! -f "$CFG" ]; then
        mkdir -p "$(dirname "$CFG")"
        echo "[]" > "$CFG"
    fi
}

# List: Liefert "Name|Path|Shortcut"
PY_LIST="import sys,json; 
try: d=json.load(open(sys.argv[1]))
except: d=[]
for r in d:
    print(f\"{r.get('name','')}|{r.get('path','')}|{r.get('shortcut','')}\")"

# Find: Sucht nach Shortcut oder Teilstring im Namen
PY_FIND="import sys,json; f,q=sys.argv[1:3]; q=q.lower();
try: d=json.load(open(f))
except: d=[]
found=None;
for r in d:
    # Exakter Shortcut Match gewinnt immer
    if r.get('shortcut','').lower()==q: found=r['path']; break
    # Sonst Fuzzy Search im Namen
    if q in r.get('name','').lower() and not found: found=r['path']
print(found or '')"

# Add/Edit (Upsert based on Path)
py_upsert() {
    # args: path name shortcut
    python3 -c "import sys,json; f,p,n,s=sys.argv[1:5];
try: d=json.load(open(f))
except: d=[]
# Remove existing entry for this path to avoid dupes
d=[i for i in d if i['path']!=p]; 
d.append({'name':n,'path':p,'shortcut':s});
# Sort by name
d.sort(key=lambda x: x['name'].lower())
json.dump(d,open(f,'w'),indent=2)" "$CFG" "$1" "$2" "$3"
}

# Delete
py_del() {
    python3 -c "import sys,json; f,p=sys.argv[1:3];
try: d=json.load(open(f))
except: d=[]
d=[i for i in d if i['path']!=p];
json.dump(d,open(f,'w'),indent=2)" "$CFG" "$1"
}

# --- ACTIONS ---

add_current() {
    ui_header "ADD REPO" "$PWD"
    local def_name=$(basename "$PWD")
    ui_input "Name" "$def_name"; local n="$VAL"
    ui_input "Shortcut (opt)" ""; local s="$VAL"
    
    ensure_db
    py_upsert "$PWD" "$n" "$s"
}

edit_repo() {
    local line="$1"
    parse_line "$line"
    # P1=Name, P2=Path, P3=Shortcut
    
    ui_header "EDIT REPO" "$P1"
    ui_input "Name" "$P1"; local n="$VAL"
    ui_input "Shortcut" "$P3"; local s="$VAL"
    
    py_upsert "$P2" "$n" "$s"
}

# --- CLI JUMP MODE (Argument provided) ---
if [ -n "$1" ]; then
    ensure_db
    if [ "$1" == "-a" ]; then
        add_current
        echo "${C_SUCCESS}âœ” Added current repo.${RESET}"
        exit 0
    fi
    
    # Search via Python
    TARGET=$(python3 -c "$PY_FIND" "$CFG" "$1")
    
    if [ -n "$TARGET" ]; then
        printf "${C_SUCCESS}ðŸš€ Jumping to $TARGET...${RESET}\n"
        if command -v code >/dev/null 2>&1; then
            code -r "$TARGET"
        else
            # Fallback fÃ¼r reines Terminal
            cd "$TARGET" && exec $SHELL
        fi
        exit 0
    else
        echo "${C_RED}Project not found: $1${RESET}"
        exit 1
    fi
fi

# --- UI MODE (Interactive) ---
ensure_db
SEL=0; VS=0; MAX=10

while true; do
    # Load Data (Python -> Bash Array)
    REPOS=()
    while IFS= read -r line; do
        [ -n "$line" ] && REPOS+=("$line")
    done < <(python3 -c "$PY_LIST" "$CFG")
    
    TOT=${#REPOS[@]}
    
    # Bounds & Scroll Logic
    [ $SEL -ge $TOT ] && SEL=$((TOT-1))
    [ $SEL -lt 0 ] && SEL=0
    [ $SEL -lt $VS ] && VS=$SEL
    [ $SEL -ge $((VS+MAX)) ] && VS=$((SEL-MAX+1))

    ui_header "REPO MANAGER" "$TOT Projects"
    
    PWD_CUR=$(pwd -P)
    
    if [ $TOT -eq 0 ]; then
        echo "  ${C_MUTED}(Database empty)${RESET}"
        echo "  DrÃ¼cke 'a', um den aktuellen Ordner zu speichern."
    else
        for (( i=0; i<MAX; i++ )); do
            IDX=$((VS+i))
            [ $IDX -ge $TOT ] && break
            
            parse_line "${REPOS[$IDX]}"
            # P1=Name, P2=Path, P3=Shortcut
            
            # Label Formatierung
            LABEL="$P1"
            [ -n "$P3" ] && LABEL="$P1 ${C_ACCENT}[$P3]${RESET}"
            
            IS_SEL="false"; [ $IDX -eq $SEL ] && IS_SEL="true"
            
            # Highlight current active repo
            IS_CUR="false"; [[ "$PWD_CUR" == "$P2" ]] && IS_CUR="true"
            
            ui_item "$LABEL" "$P2" "$IS_SEL" "$IS_CUR"
        done
    fi
    
    ui_line
    printf "${C_MUTED} [Enter] Open  [a] Add  [e] Edit  [d] Delete  [q] Quit${RESET}"
    
    read -rsn1 key
    if [[ $key == $'\x1b' ]]; then
        read -rsn2 k2
        case "$k2" in '[A') ((SEL--));; '[B') ((SEL++));; esac
    elif [[ $key == "" && $TOT -gt 0 ]]; then
        # OPEN ACTION
        parse_line "${REPOS[$SEL]}"
        cursor_on
        printf "\n${C_SUCCESS}Opening $P1...${RESET}\n"
        if command -v code >/dev/null 2>&1; then
            code -r "$P2"
            exit 0
        else
            cd "$P2" || exit 1
            exec $SHELL
        fi
        
    elif [[ $key == "a" ]]; then
        add_current
    elif [[ $key == "e" && $TOT -gt 0 ]]; then
        edit_repo "${REPOS[$SEL]}"
    elif [[ $key == "d" && $TOT -gt 0 ]]; then
        parse_line "${REPOS[$SEL]}"
        cursor_on
        printf "\n${C_DANGER}Remove '$P1' from list? [y/N]${RESET} "
        read -r y
        if [[ "$y" =~ ^[Yy]$ ]]; then
            py_del "$P2"
        fi
        cursor_off
    elif [[ $key == "q" ]]; then
        exit 0
    fi
done